#!/usr/bin/node

"use strict";

const fs = require('fs');
const esprima = require('esprima');
const APIUseWalker = require('./lib/APIUseWalker');
const colors = require('colors');
const crypto = require('crypto');
const forEachJSFileRecursive = require('./lib/util').forEachJSFileRecursive;
const uses = require('./lib/uses');
const Table = require('./lib/Table');



// Retrieves the AST of the given file contents
// A cached AST will be returned if available
// If not, the contents will be parsed and the resulting AST will be cached
function getAst(contents) {
  const checksum = crypto
        .createHash('md5')
        .update(contents, 'utf8')
        .digest('hex');
  const cacheFile = `./.cache/${checksum}`;
  if (fs.existsSync(cacheFile)) {
    return JSON.parse(fs.readFileSync(cacheFile))
  }

  try {
    let ast = esprima.parse(contents, { loc: true, tolerant: true });
    fs.writeFileSync(cacheFile, JSON.stringify(ast));
    return ast;
  } catch(err) {
    console.error('Could not parse!');
    console.dir(err);
    return null;
  }
}



const repo = process.argv[2];
const globalUses = new Map();

forEachJSFileRecursive(repo, function(filename, contents) {
  console.log(filename.green);
  let ast = getAst(contents);

  const walker = new APIUseWalker(repo, filename);
  walker.handleNode(ast);
  walker.finalize();
  uses.mergeUses(globalUses, walker._uses);
});

// console.dir(globalUses, { colors: true, depth: null });
let usesTable = new Table(0);
globalUses.forEach((useage, mName) => {
  console.log(mName);
  uses.sortUses(useage).forEach((amount, author) => {
    console.log('  ' + author.green + ': ' + amount);
    usesTable.setOrAdd(author, mName, amount);
  })
});
const repoSplits = repo.split('/').reverse();
const repoName = repoSplits[0] || repoSplits[1];
const timecode = new Date().toISOString();
fs.writeFileSync(`out/${repoName}_${timecode}.json`, uses.serializeMap(globalUses));
fs.writeFileSync(`out/${repoName}_${timecode}.csv`, usesTable.toCSV());
