#!/usr/bin/node

"use strict";

const fs = require('fs');
const esprima = require('esprima');
const APIUseWalker = require('./lib/APIUseWalker');
const colors = require('colors');
const crypto = require('crypto');
const forEachJSFileRecursive = require('./lib/util').forEachJSFileRecursive;
const listJSFilesRecursive = require('./lib/util').listJSFilesRecursive;
const uses = require('./lib/uses');
const Table = require('./lib/Table');
const async = require('async');



// Retrieves the AST of the given file contents
// A cached AST will be returned if available
// If not, the contents will be parsed and the resulting AST will be cached
function getAst(contents) {
  const checksum = crypto
        .createHash('md5')
        .update(contents, 'utf8')
        .digest('hex');
  const cacheFile = `./.cache/${checksum}`;
  if (fs.existsSync(cacheFile)) {
    return JSON.parse(fs.readFileSync(cacheFile))
  }

  try {
    let ast = esprima.parse(contents, { loc: true, tolerant: true });
    fs.writeFileSync(cacheFile, JSON.stringify(ast));
    return ast;
  } catch(err) {
    console.error('Could not parse!');
    console.dir(err);
    return null;
  }
}



const repo = process.argv[2];
if (!repo.endsWith('/')) { repo += '/' }
const globalUses = new Map();

// forEachJSFileRecursive(repo, function(filename, contents) {
//   console.log(filename.green);
//   let ast = getAst(contents);
//
//   const walker = new APIUseWalker(repo, filename);
//   walker.handleNode(ast);
//   walker.finalize();
// });

function extract(file, callback) {
  console.log(file.green);
  let ast = getAst(fs.readFileSync(file));
  const walker = new APIUseWalker(repo, file);
  walker.handleNode(ast);
  walker.finalize();
  callback(null, walker._uses);
}

let filesToAnalyze = [];
if (process.argv.length <= 3) {
  filesToAnalyze = filesToAnalyze.concat(listJSFilesRecursive(repo));
} else {
  for (let subpath of process.argv.slice(3)) {
    filesToAnalyze = filesToAnalyze.concat(listJSFilesRecursive(repo + subpath));
  }
}
async.map(filesToAnalyze, extract, (err, results) => {
  if (err)
    console.error(err);
  for (let result of results) {
    uses.mergeUses(globalUses, result);
  }
});

// console.dir(globalUses, { colors: true, depth: null });
let usesTable = new Table(0);
globalUses.forEach((useage, mName) => {
  console.log(mName);
  uses.sortUses(useage).forEach((amount, author) => {
    console.log('  ' + author.green + ': ' + amount);
    usesTable.setOrAdd(author, mName, amount);
  })
});
const repoSplits = repo.split('/').reverse();
const repoName = repoSplits[0] || repoSplits[1];
const timecode = new Date().toISOString();
fs.writeFileSync(`out/${repoName}_${timecode}.json`, uses.serializeMap(globalUses));
fs.writeFileSync(`out/${repoName}_${timecode}.csv`, usesTable.toCSV());
